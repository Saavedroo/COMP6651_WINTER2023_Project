# -*- coding: utf-8 -*-
"""K_colorable_graphs (5).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1r-QMTvQ5mApt7kokKM03E7QR2CR2lXzM
"""

import random
import networkx as nx
import matplotlib.pyplot as plt
import numpy as np
from matplotlib.widgets import Button
from matplotlib.widgets import TextBox
from matplotlib.widgets import RectangleSelector
import tkinter as tk
import random
import pickle


#def plot_values(x, y, z):
#    fig, ax = plt.subplots()
#    ax.plot([1, 2, 3], [x, y, z])
#    plt.show()
algorithm_type = None  # Define algorithm_type as a global variable with an initial value of None

def choose_algorithm():
    global algorithm_type
    algorithm_type = int(input4.get())
    print('value of algorithm_type is', algorithm_type)
    window.quit()


window = tk.Tk()
window.title("Choose algorithm")

input4_label = tk.Label(window, text="type 0 for First Fit, type 1 for CBIP and click on confirm")
input4_label.grid(row=0, column=0)
input4 = tk.Entry(window)
input4.grid(row=0, column=1)

confirm_button = tk.Button(window, text="Confirm", command=choose_algorithm)
confirm_button.grid(row=3, column=1)

window.mainloop()

if algorithm_type == 0:
  
  def get_values():
    global chromatic_number, n, N
    chromatic_number = int(input1.get())
    n = int(input2.get())
    N = int(input3.get()) 
    print('value of n is', n)
    window.quit()
    
  window = tk.Tk()
  window.title("Input Values")

  input1_label = tk.Label(window, text="Chromatic Number")
  input1_label.grid(row=0, column=0)
  input1 = tk.Entry(window)
  input1.grid(row=0, column=1)

  input2_label = tk.Label(window, text="Vertices Number")
  input2_label.grid(row=1, column=0)
  input2 = tk.Entry(window)
  input2.grid(row=1, column=1)

  input3_label = tk.Label(window, text="Graph Instances")
  input3_label.grid(row=2, column=0)
  input3 = tk.Entry(window)
  input3.grid(row=2, column=1)

  confirm_button = tk.Button(window, text="Show result!", command=get_values)
  confirm_button.grid(row=3, column=1)
  window.mainloop()
  def graph_generator(Number_of_graphs, numb_vertices, chromatic_num):
      cnt = 0
      graphs = []
      n = numb_vertices
      while(cnt < Number_of_graphs):
        if cnt% 5 == 0:
          print("ok",cnt)
        # p = random.random()
        # p_int = int(p * n)
        p1 = random.random()
        # colors = np.zeros(n)
        # colors[np.random.choice(n,p_int)] = 1
        
        while(True):
          colors = np.random.randint(chromatic_num, size=n)
          unique_integers = np.unique(colors)                                   
          if len(unique_integers) == chromatic_num:
            break

        result = []
        for h in unique_integers:    
          indices = np.where(colors == h)[0]
          random_index = np.random.choice(indices)
          result.append(random_index)

        G = nx.Graph()
        G.add_nodes_from(range(n))
        ## just to be sure we have all connected k vertices
        for i in range(chromatic_num):
          for j in range(i+1, chromatic_num):
                  G.add_edge(result[i], result[j])

        for i in range(n):
            for j in range(i+1,n):      #(i+1, n)   
                if random.random() < p1 and colors[i] !=colors[j]:
                    G.add_edge(i, j)
        cnt +=1
        graphs.append(G)
      return graphs

  all_graphs = graph_generator(N, n, chromatic_number)
  
  def reveal_neighbors(adj_list, i):
      neighbors = []
      for neigh in adj_list[i]:
        if neigh < i:
          neighbors.append(neigh)
      return neighbors

  def find_minimum_integer_not_in_list(lst):
        s = set(lst)
        i = 1
        while i in s:
            i += 1
        return i

  def first_fit(n, adj_list):
      neighbors_colors = []
      color_list = []
      for i in range(n):
        neighbors_colors = []
        neighbor_list_i = reveal_neighbors(adj_list,i)
        #print(i,'neighbors is: ', neighbor_list_i)
        for j in neighbor_list_i:
          neighbors_colors.append(color_list[j])
        xx = find_minimum_integer_not_in_list(neighbors_colors)
        #print("xx is ", xx)
        #print(i,"the neighbors have colors:", neighbors_colors)
        #print(xx)
        color_list.append(xx)
      return color_list
      

  def choose_graph(graph_number):
      G = all_graphs[graph_number]
      adj_list = nx.to_dict_of_lists(G)
      #print('this is graph number ',graph_number)
      final_color = first_fit(n, adj_list)
      #print('this is final Color: ',final_color)

      pos = nx.spring_layout(G)
      colors = []
      unique_values = list(set(final_color))
      for i in range(len(unique_values)):
        colors.append(tuple([random.uniform(0.2, 0.8) for i in range(3)]))
      #node_colors = [colors[node] for node in G.nodes()]
      node_colors = list(final_color)
      #print('colors:', colors)
      for i in range(0,len(node_colors)):
         #print('node_colors:',node_colors)
         value = node_colors[i]
         #print('value', value)
         node_colors[i] = colors[value - 1]
         #print('in i ', i,'node_colors[i]: ',node_colors[i])

      for i, node in enumerate(G.nodes()):
        nx.draw_networkx_nodes(G, pos, nodelist=[node], node_color = node_colors[i])
        edges_to_draw = list(G.edges(node))
        nx.draw_networkx_edges(G, pos, edgelist=edges_to_draw, edge_color='black')
          # Add the label for the current node
        nx.draw_networkx_labels(G, pos, labels={node: final_color[i]})
      # for i in range(len(final_color)):
        #print(final_color)
        plt.draw()
        plt.pause(1)
        if i == len(G.nodes()) - 1:
            nx.draw_networkx_edges(G, pos, edgelist=G.edges(), edge_color='black')

  ratio_list_ffit = []
  #G = all_graphs
  #adj_list = nx.to_dict_of_lists(G)
  for i in range(N):
    G = all_graphs[i]
    adj_list = nx.to_dict_of_lists(G)
    ratio_list_ffit.append(max(first_fit(n, adj_list))/chromatic_number)
  
  #print("The maximum ratio is:",max(ratio_list_ffit))
  #print("The ratio's mean is :",np.mean(np.array(ratio_list_ffit))," And the standard deviation is:",np.std(np.array(ratio_list_ffit)))

  axbox = plt.axes([0.1, 0.02, 0.8, 0.05])
  axbox.text(0.5, 0.5, f"Maximum ratio: {max(ratio_list_ffit)}, Ratio's mean:{np.mean(np.array(ratio_list_ffit))}, Standard deviation: {np.std(np.array(ratio_list_ffit))}", ha='center', va='center', transform=axbox.transAxes, fontsize= 11)
  
  axbox.spines['top'].set_visible(False)
  axbox.spines['bottom'].set_visible(False)
  axbox.spines['left'].set_visible(False)
  axbox.spines['right'].set_visible(False)
  axbox.set_xticks([])
  axbox.set_yticks([])



  def submit(text):
        plt.cla()
        choose_graph(int(text)-1)
        

  axbox = plt.axes([0.1, 0.1, 0.8, 0.05])
  text_box = TextBox(axbox, 'Input graph number',)
  text_box.on_submit(submit)


  def onselect():
    print('selected')




  ax = plt.axes([0.05, 0.2, 0.9, 0.8])
  rect_selector = RectangleSelector(ax, onselect)
  ax.set_xticklabels([])
  ax.set_yticklabels([])
  fig_manager = plt.get_current_fig_manager()
  fig_manager.window.showMaximized()

  plt.show()


    # Start tkinter event loop























# CBIP algorithm    
if algorithm_type == 1:
  def get_values():
    global  n, N
    n = int(input2.get())
    N = int(input3.get()) 
    window.quit()
  
  window = tk.Tk()
  window.title("Input Values for CBIP")

  input1_label = tk.Label(window, text="Chromatic Number is 2", anchor="center")
  input1_label.grid(row=0, column=0, columnspan=2)

  input2_label = tk.Label(window, text="Vertices Number")
  input2_label.grid(row=1, column=0)
  input2 = tk.Entry(window)
  input2.grid(row=1, column=1)

  input3_label = tk.Label(window, text="Graph Instances")
  input3_label.grid(row=2, column=0)
  input3 = tk.Entry(window)
  input3.grid(row=2, column=1)

  confirm_button = tk.Button(window, text="Show result!", command=get_values)
  confirm_button.grid(row=3, column=1)
  window.mainloop()

  def split(lst, n):
    """Split a list into exactly n sub-lists, as evenly as possible."""
    random.shuffle(lst)
    ix = np.linspace(0, len(lst), n + 1, dtype=int)
    return [lst[i:j] for i, j in zip(ix[:-1], ix[1:])]

  def get_random_subset(LIST):
      k = random.randint(1, len(LIST))
      sample = random.sample(set(LIST), k)
      return sample

  def is_vertex_connected_to_set(v, SET, N):
      for vertex in SET:
          if vertex in N[str(v)]:
              return True
      return False

  def store_as_list_of_dicts(filename, graphs):
      list_of_dicts = [nx.to_dict_of_dicts(graph) for graph in graphs]
      with open(filename, 'wb') as f:
          pickle.dump(list_of_dicts, f)

  def load_list_of_dicts(filename, create_using=nx.Graph):
      with open(filename, 'rb') as f:
          list_of_dicts = pickle.load(f)
      graphs = [create_using(graph) for graph in list_of_dicts]
      
      return graphs

  def create_k_colorable_graph(n, k):
      V = np.arange(n)
      E = []
      N = {}
      for v in V:
          N[str(v)] = []
      SETS = split(V, k) # Create k independent subsets
      
      # Connect each set with every other set
      for i in range(len(SETS)):
          SET1 = SETS[i]
          for j in range(len(SETS)):
              if i!=j:
                  SET2 = SETS[j]
                  for v1 in SET1:
                      # Check that the vertex in SET1 is not already
                      # connected to SET2
                      if not is_vertex_connected_to_set(v1, SET2, N):
                          # If it's not, connect each vertex of SET1 to a
                          # random subset of SET2
                          SUBSET2 = get_random_subset(SET2)
                          for v2 in SUBSET2:
                              edge = (v1, v2)
                              E.append(edge)
                              N[str(v1)].append(v2)
                              N[str(v2)].append(v1)
      E = set(E)
      g = nx.Graph()
      g.add_nodes_from(V)
      g.add_edges_from(E)
      return g, V, E, N


  def g_generator(Number_of_graphs, numb_vertices, chromatic_num):
      cnt = 0
      graphs = []
      all_sets = []
      n = numb_vertices
      for cnt in range(Number_of_graphs):
          G, _, _, _ = create_k_colorable_graph(numb_vertices,
                                                chromatic_num)
          graphs.append(G)
          filename = "{}-graphs_{}-vertices.pkl".format(Number_of_graphs, numb_vertices)
          store_as_list_of_dicts(filename, graphs)
      print("{} graphs successfuly created!".format(Number_of_graphs))
      return graphs

  """# The CBIP Algorithm and test"""

  def get_bipartite_independent_sets(graph):
      independent_set_1 = set()
      independent_set_2 = set()
      visited = set()

      # choose the last vertex and add it to independent set 1
      # start_vertex = list(graph.nodes())[-1]
      start_vertex = len(list(graph.nodes())) - 1
      independent_set_1.add(start_vertex)
      visited.add(start_vertex)

      # perform a breadth-first search(BFS) to add vertices to independent sets
      queue = [start_vertex]
      while queue:
          vertex = queue.pop(0)
          for neighbor in graph[vertex]:
              if neighbor not in visited:
                  # add neighbor to the opposite independent set
                  if vertex in independent_set_1:
                      independent_set_2.add(neighbor)
                  else:
                      independent_set_1.add(neighbor)
                  visited.add(neighbor)
                  queue.append(neighbor)

      # return the two independent sets
      print('independent set 1 is: ',list(independent_set_1), 'independent_set_2 is: ',list(independent_set_2))
      return list(independent_set_1), list(independent_set_2)

  def find_minimum_integer_not_in_list(lst):
      s = set(lst)
      i = 1
      while i in s:
          i += 1
      return i

  def cpib(G):
    n = len(G.nodes())
    if n<1:
      return []
    #Color the first vertice 1 as our base case.
    color_list = [1]
    for i in range(1,n):
      other_part_colors = []
      other_part = get_bipartite_independent_sets(G.subgraph(range(i+1)))[1]
      for j in other_part:
        other_part_colors.append(color_list[j])
      color = find_minimum_integer_not_in_list(other_part_colors)
      color_list.append(color)
    #print('color list is: ',color_list)
    return color_list


  all_graphs = g_generator(N, n, 2)


  def choose_graph(graph_number):
      
      
        G = all_graphs[graph_number]
        #print('this is graph number ',graph_number)
        final_color = cpib(G)
        #print('this is final Color: ',final_color)

        pos = nx.spring_layout(G)
        colors = []
        unique_values = list(set(final_color))
        for i in range(len(unique_values)):
          colors.append(tuple([random.uniform(0.2, 0.8) for i in range(3)]))
        #node_colors = [colors[node] for node in G.nodes()]
        node_colors = list(final_color)
        #print('colors:', colors)
        for i in range(0,len(node_colors)):
         #print('node_colors:',node_colors)
         value = node_colors[i]
         #print('value', value)
         node_colors[i] = colors[value - 1]
         #print('in i ', i,'node_colors[i]: ',node_colors[i])
        for i, node in enumerate(G.nodes()):
          nx.draw_networkx_nodes(G, pos, nodelist=[node], node_color = node_colors[i])
          edges_to_draw = list(G.edges(node))
          nx.draw_networkx_edges(G, pos, edgelist=edges_to_draw, edge_color='black')
            # Add the label for the current node
          nx.draw_networkx_labels(G, pos, labels={node: final_color[i]})
        # for i in range(len(final_color)):
          #print(final_color)
          plt.draw()
          plt.pause(1)
          if i == len(G.nodes()) - 1:
              nx.draw_networkx_edges(G, pos, edgelist=G.edges(), edge_color='black')


  def submit(text):
      plt.cla()
      choose_graph(int(text)-1)


  ratio_list_cbip = []
  for i in range(N):
    G = all_graphs[i]
    ratio_list_cbip.append(max(cpib(G))/2)
    with open('my_list.txt', 'w') as f:
      f.write(','.join(str(x) for x in ratio_list_cbip))
  #print("nember of vertices:", n)
  #print("The maximum ratio is:",max(ratio_list_cbip))
  #print("The ratio's mean is :",np.mean(np.array(ratio_list_cbip)),"And the standard deviation is:",np.std(np.array(ratio_list_cbip)))


  axbox = plt.axes([0.1, 0.02, 0.8, 0.05])
  axbox.text(0.5, 0.5, f"Maximum ratio: {max(ratio_list_cbip)}, Ratio's mean:{np.mean(np.array(ratio_list_cbip))}, Standard deviation: {np.std(np.array(ratio_list_cbip))}", ha='center', va='center', transform=axbox.transAxes, fontsize= 11)
  
  axbox.spines['top'].set_visible(False)
  axbox.spines['bottom'].set_visible(False)
  axbox.spines['left'].set_visible(False)
  axbox.spines['right'].set_visible(False)
  axbox.set_xticks([])
  axbox.set_yticks([])
  
  axbox = plt.axes([0.1, 0.1, 0.8, 0.05])
  text_box = TextBox(axbox, 'Input graph number',)
  text_box.on_submit(submit)
  
  #axbox = plt.axes([0.1, 0.05, 0.8, 0.05])



  def onselect():
      print('selected')   

  ax = plt.axes([0.05, 0.2, 0.9, 0.8])
  rect_selector = RectangleSelector(ax, onselect)
  ax.set_xticklabels([])
  ax.set_yticklabels([])
  
  fig_manager = plt.get_current_fig_manager()
  fig_manager.window.showMaximized()

  plt.show()

  
















